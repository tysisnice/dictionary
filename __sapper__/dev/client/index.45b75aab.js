import { I as is_function, S as SvelteComponentDev, i as init, s as safe_not_equal, e as element, a as space, c as claim_element, b as children, d as claim_text, f as detach, h as add_location, j as insert, o as mount_component, k as append, N as fix_position, O as create_animation, q as transition_in, r as transition_out, u as destroy_component, t as text, B as empty, g as attr, L as update_keyed_each, G as check_outros, v as validate_store, w as component_subscribe, l as noop, F as group_outros, P as fix_and_outro_and_destroy_block } from './index.efb24f45.js';
import { f as favorites } from './index.3f16ccce.js';
import { c as cubicOut, W as WordCard } from './WordCard.78f53de1.js';

function flip(node, animation, params) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const dx = animation.from.left - animation.to.left;
    const dy = animation.from.top - animation.to.top;
    const d = Math.sqrt(dx * dx + dy * dy);
    const { delay = 0, duration = d => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
    };
}

/* src/routes/favorites/index.svelte generated by Svelte v3.9.0 */

const file = "src/routes/favorites/index.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.entry = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (12:0) {#each faves as entry, i (entry._id)}
function create_each_block(key_1, ctx) {
	var div, t, rect, stop_animation = noop, current;

	var wordcard = new WordCard({
		props: { entry: ctx.entry, open: "true" },
		$$inline: true
	});

	return {
		key: key_1,

		first: null,

		c: function create() {
			div = element("div");
			wordcard.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			wordcard.$$.fragment.l(div_nodes);
			t = claim_text(div_nodes, "\n  ");
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(div, file, 12, 2, 397);
			this.first = div;
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(wordcard, div, null);
			append(div, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed.faves) wordcard_changes.entry = ctx.entry;
			wordcard.$set(wordcard_changes);
		},

		r: function measure_1() {
			rect = div.getBoundingClientRect();
		},

		f: function fix() {
			fix_position(div);
			stop_animation();
		},

		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div, rect, flip, {duration: 220});
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(wordcard);
		}
	};
}

function create_fragment(ctx) {
	var h20, t0, t1, t2, h21, t3, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

	var wordcard = new WordCard({
		props: { entry: ctx.$wordOfTheDay, open: "true" },
		$$inline: true
	});

	var each_value = ctx.faves;

	const get_key = ctx => ctx.entry._id;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			h20 = element("h2");
			t0 = text("Word of the Day");
			t1 = space();
			wordcard.$$.fragment.c();
			t2 = space();
			h21 = element("h2");
			t3 = text("My Saved Words");
			t4 = space();

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

			each_1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			h20 = claim_element(nodes, "H2", { class: true }, false);
			var h20_nodes = children(h20);

			t0 = claim_text(h20_nodes, "Word of the Day");
			h20_nodes.forEach(detach);
			t1 = claim_text(nodes, "\n");
			wordcard.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\n");

			h21 = claim_element(nodes, "H2", { class: true }, false);
			var h21_nodes = children(h21);

			t3 = claim_text(h21_nodes, "My Saved Words");
			h21_nodes.forEach(detach);
			t4 = claim_text(nodes, "\n");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nodes);

			each_1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(h20, "class", "top svelte-1ig13xx");
			add_location(h20, file, 8, 0, 249);
			attr(h21, "class", "svelte-1ig13xx");
			add_location(h21, file, 10, 0, 333);
		},

		m: function mount(target, anchor) {
			insert(target, h20, anchor);
			append(h20, t0);
			insert(target, t1, anchor);
			mount_component(wordcard, target, anchor);
			insert(target, t2, anchor);
			insert(target, h21, anchor);
			append(h21, t3);
			insert(target, t4, anchor);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed.$wordOfTheDay) wordcard_changes.entry = ctx.$wordOfTheDay;
			wordcard.$set(wordcard_changes);

			const each_value = ctx.faves;

			group_outros();
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);

			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h20);
				detach(t1);
			}

			destroy_component(wordcard, detaching);

			if (detaching) {
				detach(t2);
				detach(h21);
				detach(t4);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let $savedWords, $wordOfTheDay;

	
  const { savedWords, wordOfTheDay } = favorites; validate_store(savedWords, 'savedWords'); component_subscribe($$self, savedWords, $$value => { $savedWords = $$value; $$invalidate('$savedWords', $savedWords); }); validate_store(wordOfTheDay, 'wordOfTheDay'); component_subscribe($$self, wordOfTheDay, $$value => { $wordOfTheDay = $$value; $$invalidate('$wordOfTheDay', $wordOfTheDay); });

	let faves;

	$$self.$$.update = ($$dirty = { $savedWords: 1 }) => {
		if ($$dirty.$savedWords) { $$invalidate('faves', faves = $savedWords.reverse()); }
	};

	return {
		savedWords,
		wordOfTheDay,
		faves,
		$wordOfTheDay
	};
}

class Index extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

export default Index;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguNDViNzVhYWIuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdmVsdGUvYW5pbWF0ZS9pbmRleC5tanMiLCIuLi8uLi8uLi9zcmMvcm91dGVzL2Zhdm9yaXRlcy9pbmRleC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3ViaWNPdXQgfSBmcm9tICcuLi9lYXNpbmcnO1xuaW1wb3J0IHsgaXNfZnVuY3Rpb24gfSBmcm9tICcuLi9pbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGZsaXAobm9kZSwgYW5pbWF0aW9uLCBwYXJhbXMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICBjb25zdCBkeCA9IGFuaW1hdGlvbi5mcm9tLmxlZnQgLSBhbmltYXRpb24udG8ubGVmdDtcbiAgICBjb25zdCBkeSA9IGFuaW1hdGlvbi5mcm9tLnRvcCAtIGFuaW1hdGlvbi50by50b3A7XG4gICAgY29uc3QgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgY29uc3QgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gZCA9PiBNYXRoLnNxcnQoZCkgKiAxMjAsIGVhc2luZyA9IGN1YmljT3V0IH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uOiBpc19mdW5jdGlvbihkdXJhdGlvbikgPyBkdXJhdGlvbihkKSA6IGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgdHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCAke3UgKiBkeX1weCk7YFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGZsaXAgfTtcbiIsIjxzY3JpcHQ+XG4gIGltcG9ydCB7IGZsaXAgfSBmcm9tICdzdmVsdGUvYW5pbWF0ZSc7XG4gIGltcG9ydCBXb3JkQ2FyZCBmcm9tICcuLi8uLi9jb21wb25lbnRzL1dvcmRDYXJkLnN2ZWx0ZSc7XG4gIGltcG9ydCB7IGZhdm9yaXRlcyB9IGZyb20gJy4uLy4uL3N0b3JlJztcbiAgY29uc3QgeyBzYXZlZFdvcmRzLCB3b3JkT2ZUaGVEYXkgfSA9IGZhdm9yaXRlcztcbiAgJDogZmF2ZXMgPSAkc2F2ZWRXb3Jkcy5yZXZlcnNlKCk7XG48L3NjcmlwdD5cblxuPGgyIGNsYXNzPVwidG9wXCI+V29yZCBvZiB0aGUgRGF5PC9oMj5cbjxXb3JkQ2FyZCBlbnRyeT17JHdvcmRPZlRoZURheX0gb3Blbj1cInRydWVcIiAvPlxuPGgyPk15IFNhdmVkIFdvcmRzPC9oMj5cbnsjZWFjaCBmYXZlcyBhcyBlbnRyeSwgaSAoZW50cnkuX2lkKX1cbiAgPGRpdiBhbmltYXRlOmZsaXA9e3tkdXJhdGlvbjogMjIwfX0+XG4gICAgPFdvcmRDYXJkIHtlbnRyeX0gb3Blbj1cInRydWVcIiAvPlxuICA8L2Rpdj5cbnsvZWFjaH1cblxuXG48c3R5bGU+XG4gIGgyIHtcbiAgICBtYXJnaW46IDMwcHggMHB4IDE1cHggMHB4O1xuICAgIG1heC13aWR0aDogOTV2dztcbiAgICB3aWR0aDogMzYwcHg7XG4gICAgZm9udC1zaXplOiAzMHB4O1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIGNvbG9yOiAjNTU1O1xuICB9XG4gIGgyLnRvcCB7XG4gICAgbWFyZ2luLXRvcDogMjBweDtcbiAgfVxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUdBLFNBQVMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFO0lBQ25DLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLEtBQUssTUFBTSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0lBQ3BFLE1BQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ25ELE1BQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ2pELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkMsTUFBTSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxNQUFNLEdBQUcsUUFBUSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQ3BGLE9BQU87UUFDSCxLQUFLO1FBQ0wsUUFBUSxFQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUTtRQUN4RCxNQUFNO1FBQ04sR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO0tBQ2pGLENBQUM7Q0FDTDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQ0hjLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7bURBQUwsS0FBSzs7Ozs7Ozs7Ozs7Ozs7O3NEQURDLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBSG5CLGFBQWE7Ozs7c0JBRXZCLEtBQUs7OzRCQUFjLEtBQUssQ0FBQyxHQUFHOztnQ0FBakM7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQUE7Ozs7Ozs7OzJEQUZlLGFBQWE7OzswQkFFdkIsS0FBSzs7O21DQUFWOzttQ0FBQTs7Ozs7Ozs7a0NBQUE7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7O0VBUEEsTUFBTSxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsR0FBRyw2VkFBUyxDQUFDOzs7OzttREFDNUMsS0FBSyxHQUFHLFdBQVcsQ0FBQyxPQUFPLEdBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7In0=
