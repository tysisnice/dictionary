import { i as is_function, S as SvelteComponentDev, a as init, s as safe_not_equal, e as element, b as space, c as claim_element, d as children, f as claim_text, g as detach, j as add_location, l as insert, o as mount_component, m as append, P as fix_position, Q as create_animation, p as transition_in, q as transition_out, u as destroy_component, t as text, D as empty, h as attr, N as update_keyed_each, J as check_outros, M as onMount, n as noop, I as group_outros, R as fix_and_outro_and_destroy_block } from './index.6e2061dd.js';
import { f as favorites } from './index.2be2201c.js';
import { c as cubicOut, W as WordCard } from './WordCard.7435cdcc.js';

function flip(node, animation, params) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const dx = animation.from.left - animation.to.left;
    const dy = animation.from.top - animation.to.top;
    const d = Math.sqrt(dx * dx + dy * dy);
    const { delay = 0, duration = d => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
    };
}

/* src\routes\favorites.svelte generated by Svelte v3.9.0 */

const file = "src\\routes\\favorites.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.entry = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (20:0) {#each _savedWords as entry, i (entry._id)}
function create_each_block(key_1, ctx) {
	var div, t, rect, stop_animation = noop, current;

	var wordcard = new WordCard({
		props: { entry: ctx.entry, open: "true" },
		$$inline: true
	});

	return {
		key: key_1,

		first: null,

		c: function create() {
			div = element("div");
			wordcard.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			wordcard.$$.fragment.l(div_nodes);
			t = claim_text(div_nodes, "\r\n  ");
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(div, file, 20, 2, 664);
			this.first = div;
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(wordcard, div, null);
			append(div, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed._savedWords) wordcard_changes.entry = ctx.entry;
			wordcard.$set(wordcard_changes);
		},

		r: function measure_1() {
			rect = div.getBoundingClientRect();
		},

		f: function fix() {
			fix_position(div);
			stop_animation();
		},

		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div, rect, flip, {duration: 220});
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(wordcard);
		}
	};
}

function create_fragment(ctx) {
	var h20, t0, t1, t2, h21, t3, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

	var wordcard = new WordCard({
		props: { entry: ctx._wordOfTheDay, open: "true" },
		$$inline: true
	});

	var each_value = ctx._savedWords;

	const get_key = ctx => ctx.entry._id;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			h20 = element("h2");
			t0 = text("Word of the Day");
			t1 = space();
			wordcard.$$.fragment.c();
			t2 = space();
			h21 = element("h2");
			t3 = text("My Saved Words");
			t4 = space();

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

			each_1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			h20 = claim_element(nodes, "H2", { class: true }, false);
			var h20_nodes = children(h20);

			t0 = claim_text(h20_nodes, "Word of the Day");
			h20_nodes.forEach(detach);
			t1 = claim_text(nodes, "\r\n");
			wordcard.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\r\n");

			h21 = claim_element(nodes, "H2", { class: true }, false);
			var h21_nodes = children(h21);

			t3 = claim_text(h21_nodes, "My Saved Words");
			h21_nodes.forEach(detach);
			t4 = claim_text(nodes, "\r\n");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nodes);

			each_1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(h20, "class", "top svelte-6glch5");
			add_location(h20, file, 16, 0, 506);
			attr(h21, "class", "svelte-6glch5");
			add_location(h21, file, 18, 0, 592);
		},

		m: function mount(target, anchor) {
			insert(target, h20, anchor);
			append(h20, t0);
			insert(target, t1, anchor);
			mount_component(wordcard, target, anchor);
			insert(target, t2, anchor);
			insert(target, h21, anchor);
			append(h21, t3);
			insert(target, t4, anchor);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed._wordOfTheDay) wordcard_changes.entry = ctx._wordOfTheDay;
			wordcard.$set(wordcard_changes);

			const each_value = ctx._savedWords;

			group_outros();
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);

			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h20);
				detach(t1);
			}

			destroy_component(wordcard, detaching);

			if (detaching) {
				detach(t2);
				detach(h21);
				detach(t4);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
  const { savedWords, wordOfTheDay } = favorites;
  let _savedWords = [];
  let _wordOfTheDay;

  onMount(() => savedWords.subscribe(val => { const $$result = _savedWords = val.reverse(); $$invalidate('_savedWords', _savedWords); return $$result; }));
  onMount(() => wordOfTheDay.subscribe(val => { const $$result = _wordOfTheDay = val; $$invalidate('_wordOfTheDay', _wordOfTheDay); return $$result; }));
  // TODO add text for when there are no favorited words

	return { _savedWords, _wordOfTheDay };
}

class Favorites extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

export default Favorites;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmF2b3JpdGVzLjQ0NGVhNDU2LmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2FuaW1hdGUvaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mYXZvcml0ZXMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nJztcbmltcG9ydCB7IGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBmbGlwKG5vZGUsIGFuaW1hdGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3QgZHggPSBhbmltYXRpb24uZnJvbS5sZWZ0IC0gYW5pbWF0aW9uLnRvLmxlZnQ7XG4gICAgY29uc3QgZHkgPSBhbmltYXRpb24uZnJvbS50b3AgLSBhbmltYXRpb24udG8udG9wO1xuICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMTIwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwgJHt1ICogZHl9cHgpO2BcbiAgICB9O1xufVxuXG5leHBvcnQgeyBmbGlwIH07XG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7b25Nb3VudH0gZnJvbSAnc3ZlbHRlJztcclxuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnO1xyXG4gIGltcG9ydCBXb3JkQ2FyZCBmcm9tICcuLi9jb21wb25lbnRzL1dvcmRDYXJkLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgZmF2b3JpdGVzIH0gZnJvbSAnLi4vc3RvcmUnO1xyXG4gIGNvbnN0IHsgc2F2ZWRXb3Jkcywgd29yZE9mVGhlRGF5IH0gPSBmYXZvcml0ZXM7XHJcbiAgbGV0IF9zYXZlZFdvcmRzID0gW107XHJcbiAgbGV0IF93b3JkT2ZUaGVEYXk7XHJcblxyXG4gIG9uTW91bnQoKCkgPT4gc2F2ZWRXb3Jkcy5zdWJzY3JpYmUodmFsID0+IF9zYXZlZFdvcmRzID0gdmFsLnJldmVyc2UoKSkpO1xyXG4gIG9uTW91bnQoKCkgPT4gd29yZE9mVGhlRGF5LnN1YnNjcmliZSh2YWwgPT4gX3dvcmRPZlRoZURheSA9IHZhbCkpO1xyXG4gIC8vIFRPRE8gYWRkIHRleHQgZm9yIHdoZW4gdGhlcmUgYXJlIG5vIGZhdm9yaXRlZCB3b3Jkc1xyXG48L3NjcmlwdD5cclxuXHJcblxyXG5cclxuPGgyIGNsYXNzPVwidG9wXCI+V29yZCBvZiB0aGUgRGF5PC9oMj5cclxuPFdvcmRDYXJkIGVudHJ5PXtfd29yZE9mVGhlRGF5fSBvcGVuPVwidHJ1ZVwiIC8+XHJcbjxoMj5NeSBTYXZlZCBXb3JkczwvaDI+XHJcbnsjZWFjaCBfc2F2ZWRXb3JkcyBhcyBlbnRyeSwgaSAoZW50cnkuX2lkKX1cclxuICA8ZGl2IGFuaW1hdGU6ZmxpcD17e2R1cmF0aW9uOiAyMjB9fT5cclxuICAgIDxXb3JkQ2FyZCB7ZW50cnl9IG9wZW49XCJ0cnVlXCIgLz5cclxuICA8L2Rpdj5cclxuey9lYWNofVxyXG5cclxuXHJcblxyXG48c3R5bGU+XHJcbiAgaDIge1xyXG4gICAgbWFyZ2luOiAzMHB4IDBweCAxNXB4IDBweDtcclxuICAgIG1heC13aWR0aDogOTV2dztcclxuICAgIHdpZHRoOiAzNjBweDtcclxuICAgIGZvbnQtc2l6ZTogMjZweDtcclxuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xyXG4gICAgY29sb3I6ICM1NTU7XHJcbiAgfVxyXG4gIGgyLnRvcCB7XHJcbiAgICBtYXJnaW4tdG9wOiA1cHg7XHJcbiAgfVxyXG48L3N0eWxlPiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBR0EsU0FBUyxJQUFJLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUU7SUFDbkMsTUFBTSxLQUFLLEdBQUcsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsTUFBTSxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsS0FBSyxNQUFNLEdBQUcsRUFBRSxHQUFHLEtBQUssQ0FBQyxTQUFTLENBQUM7SUFDcEUsTUFBTSxFQUFFLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7SUFDbkQsTUFBTSxFQUFFLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUM7SUFDakQsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztJQUN2QyxNQUFNLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxRQUFRLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxFQUFFLE1BQU0sR0FBRyxRQUFRLEVBQUUsR0FBRyxNQUFNLENBQUM7SUFDcEYsT0FBTztRQUNILEtBQUs7UUFDTCxRQUFRLEVBQUUsV0FBVyxDQUFDLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsR0FBRyxRQUFRO1FBQ3hELE1BQU07UUFDTixHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUM7S0FDakYsQ0FBQztDQUNMOzs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JDS2MsS0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5REFBTCxLQUFLOzs7Ozs7Ozs7Ozs7Ozs7c0RBREMsQ0FBQyxRQUFRLEVBQUUsR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztzQkFIbkIsYUFBYTs7OztzQkFFdkIsV0FBVzs7NEJBQWMsS0FBSyxDQUFDLEdBQUc7O2dDQUF2Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFBQTs7Ozs7Ozs7MkRBRmUsYUFBYTs7OzBCQUV2QixXQUFXOzs7bUNBQWhCOzttQ0FBQTs7Ozs7Ozs7a0NBQUE7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7OztFQWRBLE1BQU0sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLEdBQUcsU0FBUyxDQUFDO0VBQy9DLElBQUksV0FBVyxHQUFHLEVBQUUsQ0FBQztFQUNyQixJQUFJLGFBQWEsQ0FBQzs7RUFFbEIsT0FBTyxDQUFDLE1BQU0sVUFBVSxDQUFDLFNBQVMsQ0FBQyxHQUFHLHVCQUFJLFdBQVcsR0FBRyxHQUFHLENBQUMsT0FBTyxnRUFBRSxDQUFDLENBQUMsQ0FBQztFQUN4RSxPQUFPLENBQUMsTUFBTSxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsdUJBQUksYUFBYSxHQUFHLHFFQUFHLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7In0=
