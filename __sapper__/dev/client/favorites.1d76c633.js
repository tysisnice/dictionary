import { i as is_function, S as SvelteComponentDev, a as init, s as safe_not_equal, e as element, b as space, c as claim_element, d as children, f as claim_text, g as detach, k as add_location, l as insert, p as mount_component, m as append, P as fix_position, Q as create_animation, u as transition_in, v as transition_out, w as destroy_component, t as text, D as empty, h as attr, N as update_keyed_each, J as check_outros, M as onMount, n as noop, I as group_outros, R as fix_and_outro_and_destroy_block } from './index.37edae6e.js';
import { f as favorites } from './index.071b1cc5.js';
import { c as cubicOut, W as WordCard } from './WordCard.6c176ff1.js';

function flip(node, animation, params) {
    const style = getComputedStyle(node);
    const transform = style.transform === 'none' ? '' : style.transform;
    const dx = animation.from.left - animation.to.left;
    const dy = animation.from.top - animation.to.top;
    const d = Math.sqrt(dx * dx + dy * dy);
    const { delay = 0, duration = d => Math.sqrt(d) * 120, easing = cubicOut } = params;
    return {
        delay,
        duration: is_function(duration) ? duration(d) : duration,
        easing,
        css: (_t, u) => `transform: ${transform} translate(${u * dx}px, ${u * dy}px);`
    };
}

/* src\routes\favorites.svelte generated by Svelte v3.9.0 */

const file = "src\\routes\\favorites.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = Object.create(ctx);
	child_ctx.entry = list[i];
	child_ctx.i = i;
	return child_ctx;
}

// (20:0) {#each _savedWords as entry, i (entry._id)}
function create_each_block(key_1, ctx) {
	var div, t, rect, stop_animation = noop, current;

	var wordcard = new WordCard({
		props: { entry: ctx.entry, open: "true" },
		$$inline: true
	});

	return {
		key: key_1,

		first: null,

		c: function create() {
			div = element("div");
			wordcard.$$.fragment.c();
			t = space();
			this.h();
		},

		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {}, false);
			var div_nodes = children(div);

			wordcard.$$.fragment.l(div_nodes);
			t = claim_text(div_nodes, "\r\n  ");
			div_nodes.forEach(detach);
			this.h();
		},

		h: function hydrate() {
			add_location(div, file, 20, 2, 608);
			this.first = div;
		},

		m: function mount(target, anchor) {
			insert(target, div, anchor);
			mount_component(wordcard, div, null);
			append(div, t);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed._savedWords) wordcard_changes.entry = ctx.entry;
			wordcard.$set(wordcard_changes);
		},

		r: function measure_1() {
			rect = div.getBoundingClientRect();
		},

		f: function fix() {
			fix_position(div);
			stop_animation();
		},

		a: function animate() {
			stop_animation();
			stop_animation = create_animation(div, rect, flip, {duration: 220});
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);
			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_component(wordcard);
		}
	};
}

function create_fragment(ctx) {
	var h20, t0, t1, t2, h21, t3, t4, each_blocks = [], each_1_lookup = new Map(), each_1_anchor, current;

	var wordcard = new WordCard({
		props: { entry: ctx._wordOfTheDay, open: "true" },
		$$inline: true
	});

	var each_value = ctx._savedWords;

	const get_key = ctx => ctx.entry._id;

	for (var i = 0; i < each_value.length; i += 1) {
		let child_ctx = get_each_context(ctx, each_value, i);
		let key = get_key(child_ctx);
		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
	}

	return {
		c: function create() {
			h20 = element("h2");
			t0 = text("Word of the Day");
			t1 = space();
			wordcard.$$.fragment.c();
			t2 = space();
			h21 = element("h2");
			t3 = text("My Saved Words");
			t4 = space();

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].c();

			each_1_anchor = empty();
			this.h();
		},

		l: function claim(nodes) {
			h20 = claim_element(nodes, "H2", { class: true }, false);
			var h20_nodes = children(h20);

			t0 = claim_text(h20_nodes, "Word of the Day");
			h20_nodes.forEach(detach);
			t1 = claim_text(nodes, "\r\n");
			wordcard.$$.fragment.l(nodes);
			t2 = claim_text(nodes, "\r\n");

			h21 = claim_element(nodes, "H2", { class: true }, false);
			var h21_nodes = children(h21);

			t3 = claim_text(h21_nodes, "My Saved Words");
			h21_nodes.forEach(detach);
			t4 = claim_text(nodes, "\r\n");

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].l(nodes);

			each_1_anchor = empty();
			this.h();
		},

		h: function hydrate() {
			attr(h20, "class", "top svelte-6glch5");
			add_location(h20, file, 16, 0, 450);
			attr(h21, "class", "svelte-6glch5");
			add_location(h21, file, 18, 0, 536);
		},

		m: function mount(target, anchor) {
			insert(target, h20, anchor);
			append(h20, t0);
			insert(target, t1, anchor);
			mount_component(wordcard, target, anchor);
			insert(target, t2, anchor);
			insert(target, h21, anchor);
			append(h21, t3);
			insert(target, t4, anchor);

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].m(target, anchor);

			insert(target, each_1_anchor, anchor);
			current = true;
		},

		p: function update(changed, ctx) {
			var wordcard_changes = {};
			if (changed._wordOfTheDay) wordcard_changes.entry = ctx._wordOfTheDay;
			wordcard.$set(wordcard_changes);

			const each_value = ctx._savedWords;

			group_outros();
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].r();
			each_blocks = update_keyed_each(each_blocks, changed, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, fix_and_outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
			for (let i = 0; i < each_blocks.length; i += 1) each_blocks[i].a();
			check_outros();
		},

		i: function intro(local) {
			if (current) return;
			transition_in(wordcard.$$.fragment, local);

			for (var i = 0; i < each_value.length; i += 1) transition_in(each_blocks[i]);

			current = true;
		},

		o: function outro(local) {
			transition_out(wordcard.$$.fragment, local);

			for (i = 0; i < each_blocks.length; i += 1) transition_out(each_blocks[i]);

			current = false;
		},

		d: function destroy(detaching) {
			if (detaching) {
				detach(h20);
				detach(t1);
			}

			destroy_component(wordcard, detaching);

			if (detaching) {
				detach(t2);
				detach(h21);
				detach(t4);
			}

			for (i = 0; i < each_blocks.length; i += 1) each_blocks[i].d(detaching);

			if (detaching) {
				detach(each_1_anchor);
			}
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	
  const { savedWords, wordOfTheDay } = favorites;
  let _savedWords = [];
  let _wordOfTheDay;

  onMount(() => savedWords.subscribe(val => { const $$result = _savedWords = val.reverse(); $$invalidate('_savedWords', _savedWords); return $$result; }));
  onMount(() => wordOfTheDay.subscribe(val => { const $$result = _wordOfTheDay = val; $$invalidate('_wordOfTheDay', _wordOfTheDay); return $$result; }));

	return { _savedWords, _wordOfTheDay };
}

class Favorites extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, []);
	}
}

export default Favorites;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmF2b3JpdGVzLjFkNzZjNjMzLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi9ub2RlX21vZHVsZXMvc3ZlbHRlL2FuaW1hdGUvaW5kZXgubWpzIiwiLi4vLi4vLi4vc3JjL3JvdXRlcy9mYXZvcml0ZXMuc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGN1YmljT3V0IH0gZnJvbSAnLi4vZWFzaW5nJztcbmltcG9ydCB7IGlzX2Z1bmN0aW9uIH0gZnJvbSAnLi4vaW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBmbGlwKG5vZGUsIGFuaW1hdGlvbiwgcGFyYW1zKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3QgZHggPSBhbmltYXRpb24uZnJvbS5sZWZ0IC0gYW5pbWF0aW9uLnRvLmxlZnQ7XG4gICAgY29uc3QgZHkgPSBhbmltYXRpb24uZnJvbS50b3AgLSBhbmltYXRpb24udG8udG9wO1xuICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IGQgPT4gTWF0aC5zcXJ0KGQpICogMTIwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbjogaXNfZnVuY3Rpb24oZHVyYXRpb24pID8gZHVyYXRpb24oZCkgOiBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IChfdCwgdSkgPT4gYHRyYW5zZm9ybTogJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke3UgKiBkeH1weCwgJHt1ICogZHl9cHgpO2BcbiAgICB9O1xufVxuXG5leHBvcnQgeyBmbGlwIH07XG4iLCI8c2NyaXB0PlxyXG4gIGltcG9ydCB7b25Nb3VudH0gZnJvbSAnc3ZlbHRlJztcclxuICBpbXBvcnQgeyBmbGlwIH0gZnJvbSAnc3ZlbHRlL2FuaW1hdGUnO1xyXG4gIGltcG9ydCBXb3JkQ2FyZCBmcm9tICcuLi9jb21wb25lbnRzL1dvcmRDYXJkLnN2ZWx0ZSc7XHJcbiAgaW1wb3J0IHsgZmF2b3JpdGVzIH0gZnJvbSAnLi4vc3RvcmUnO1xyXG4gIGNvbnN0IHsgc2F2ZWRXb3Jkcywgd29yZE9mVGhlRGF5IH0gPSBmYXZvcml0ZXM7XHJcbiAgbGV0IF9zYXZlZFdvcmRzID0gW107XHJcbiAgbGV0IF93b3JkT2ZUaGVEYXk7XHJcblxyXG4gIG9uTW91bnQoKCkgPT4gc2F2ZWRXb3Jkcy5zdWJzY3JpYmUodmFsID0+IF9zYXZlZFdvcmRzID0gdmFsLnJldmVyc2UoKSkpO1xyXG4gIG9uTW91bnQoKCkgPT4gd29yZE9mVGhlRGF5LnN1YnNjcmliZSh2YWwgPT4gX3dvcmRPZlRoZURheSA9IHZhbCkpO1xyXG5cclxuPC9zY3JpcHQ+XHJcblxyXG5cclxuXHJcbjxoMiBjbGFzcz1cInRvcFwiPldvcmQgb2YgdGhlIERheTwvaDI+XHJcbjxXb3JkQ2FyZCBlbnRyeT17X3dvcmRPZlRoZURheX0gb3Blbj1cInRydWVcIiAvPlxyXG48aDI+TXkgU2F2ZWQgV29yZHM8L2gyPlxyXG57I2VhY2ggX3NhdmVkV29yZHMgYXMgZW50cnksIGkgKGVudHJ5Ll9pZCl9XHJcbiAgPGRpdiBhbmltYXRlOmZsaXA9e3tkdXJhdGlvbjogMjIwfX0+XHJcbiAgICA8V29yZENhcmQge2VudHJ5fSBvcGVuPVwidHJ1ZVwiIC8+XHJcbiAgPC9kaXY+XHJcbnsvZWFjaH1cclxuXHJcblxyXG5cclxuPHN0eWxlPlxyXG4gIGgyIHtcclxuICAgIG1hcmdpbjogMzBweCAwcHggMTVweCAwcHg7XHJcbiAgICBtYXgtd2lkdGg6IDk1dnc7XHJcbiAgICB3aWR0aDogMzYwcHg7XHJcbiAgICBmb250LXNpemU6IDI2cHg7XHJcbiAgICBmb250LXdlaWdodDogYm9sZDtcclxuICAgIGNvbG9yOiAjNTU1O1xyXG4gIH1cclxuICBoMi50b3Age1xyXG4gICAgbWFyZ2luLXRvcDogNXB4O1xyXG4gIH1cclxuPC9zdHlsZT4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUdBLFNBQVMsSUFBSSxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFO0lBQ25DLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3JDLE1BQU0sU0FBUyxHQUFHLEtBQUssQ0FBQyxTQUFTLEtBQUssTUFBTSxHQUFHLEVBQUUsR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDO0lBQ3BFLE1BQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsSUFBSSxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDO0lBQ25ELE1BQU0sRUFBRSxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMsR0FBRyxHQUFHLFNBQVMsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDO0lBQ2pELE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDdkMsTUFBTSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsUUFBUSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsRUFBRSxNQUFNLEdBQUcsUUFBUSxFQUFFLEdBQUcsTUFBTSxDQUFDO0lBQ3BGLE9BQU87UUFDSCxLQUFLO1FBQ0wsUUFBUSxFQUFFLFdBQVcsQ0FBQyxRQUFRLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLEdBQUcsUUFBUTtRQUN4RCxNQUFNO1FBQ04sR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO0tBQ2pGLENBQUM7Q0FDTDs7Ozs7Ozs7Ozs7Ozs7Ozs7O3NCQ0tjLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7eURBQUwsS0FBSzs7Ozs7Ozs7Ozs7Ozs7O3NEQURDLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7c0JBSG5CLGFBQWE7Ozs7c0JBRXZCLFdBQVc7OzRCQUFjLEtBQUssQ0FBQyxHQUFHOztnQ0FBdkM7Ozs7Ozs7Ozs7Ozs7Ozs7OytCQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K0JBQUE7Ozs7Ozs7OzJEQUZlLGFBQWE7OzswQkFFdkIsV0FBVzs7O21DQUFoQjs7bUNBQUE7Ozs7Ozs7O2tDQUFBOzs7Ozs7OzsrQkFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsrQkFBQTs7Ozs7Ozs7Ozs7RUFkQSxNQUFNLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxHQUFHLFNBQVMsQ0FBQztFQUMvQyxJQUFJLFdBQVcsR0FBRyxFQUFFLENBQUM7RUFDckIsSUFBSSxhQUFhLENBQUM7O0VBRWxCLE9BQU8sQ0FBQyxNQUFNLFVBQVUsQ0FBQyxTQUFTLENBQUMsR0FBRyx1QkFBSSxXQUFXLEdBQUcsR0FBRyxDQUFDLE9BQU8sZ0VBQUUsQ0FBQyxDQUFDLENBQUM7RUFDeEUsT0FBTyxDQUFDLE1BQU0sWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLHVCQUFJLGFBQWEsR0FBRyxxRUFBRyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7In0=
